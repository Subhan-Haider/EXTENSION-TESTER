"""
CVE and Vulnerability Database Integration
Scans package.json dependencies for known vulnerabilities
"""
import json
import re
from pathlib import Path
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Scans extension dependencies for known vulnerabilities.
    Integrates with OSV database and npm audit style checks.
    """
    
    def __init__(self):
        # Known vulnerable package patterns (simplified database)
        # In production, this would query OSV API or NVD
        self.known_vulnerabilities = {
            'lodash': {
                'versions': ['<4.17.21'],
                'cve': 'CVE-2021-23337',
                'severity': 'HIGH',
                'description': 'Command injection vulnerability'
            },
            'jquery': {
                'versions': ['<3.5.0'],
                'cve': 'CVE-2020-11022',
                'severity': 'MEDIUM',
                'description': 'XSS vulnerability in htmlPrefilter'
            },
            'axios': {
                'versions': ['<0.21.1'],
                'cve': 'CVE-2020-28168',
                'severity': 'MEDIUM',
                'description': 'SSRF vulnerability'
            },
            'minimist': {
                'versions': ['<1.2.6'],
                'cve': 'CVE-2021-44906',
                'severity': 'CRITICAL',
                'description': 'Prototype pollution'
            }
        }
    
    def scan_extension(self, extension_path: str) -> Dict:
        """
        Scan extension for dependency vulnerabilities.
        
        Returns:
            Dict with vulnerabilities found, severity counts, and recommendations
        """
        path = Path(extension_path)
        
        results = {
            'vulnerabilities': [],
            'total_count': 0,
            'severity_counts': {
                'CRITICAL': 0,
                'HIGH': 0,
                'MEDIUM': 0,
                'LOW': 0
            },
            'dependencies_scanned': 0,
            'recommendations': []
        }
        
        # Check for package.json
        package_json = path / 'package.json'
        if not package_json.exists():
            results['note'] = 'No package.json found - skipping dependency scan'
            return results
        
        try:
            with open(package_json, 'r', encoding='utf-8') as f:
                package_data = json.load(f)
        except Exception as e:
            results['error'] = f'Failed to parse package.json: {e}'
            return results
        
        # Scan dependencies
        dependencies = package_data.get('dependencies', {})
        dev_dependencies = package_data.get('devDependencies', {})
        all_deps = {**dependencies, **dev_dependencies}
        
        results['dependencies_scanned'] = len(all_deps)
        
        for pkg_name, version in all_deps.items():
            vulns = self._check_package_vulnerability(pkg_name, version)
            if vulns:
                results['vulnerabilities'].extend(vulns)
                for vuln in vulns:
                    severity = vuln.get('severity', 'LOW')
                    results['severity_counts'][severity] += 1
                    results['total_count'] += 1
        
        # Generate recommendations
        if results['severity_counts']['CRITICAL'] > 0:
            results['recommendations'].append(
                'ðŸ”´ CRITICAL: Update dependencies immediately - critical vulnerabilities found'
            )
        if results['severity_counts']['HIGH'] > 0:
            results['recommendations'].append(
                'âš ï¸ HIGH: Update vulnerable dependencies as soon as possible'
            )
        if results['total_count'] > 0:
            results['recommendations'].append(
                f'Run "npm audit fix" to automatically update {results["total_count"]} vulnerable packages'
            )
        else:
            results['recommendations'].append(
                'âœ… No known vulnerabilities found in dependencies'
            )
        
        return results
    
    def _check_package_vulnerability(self, package_name: str, version: str) -> List[Dict]:
        """Check if a specific package version has known vulnerabilities"""
        vulnerabilities = []
        
        if package_name not in self.known_vulnerabilities:
            return vulnerabilities
        
        vuln_info = self.known_vulnerabilities[package_name]
        
        # Parse version (simplified - real implementation would use semver)
        version_clean = self._clean_version(version)
        
        # Check if version matches vulnerable pattern
        for vuln_version_pattern in vuln_info['versions']:
            if self._version_matches_pattern(version_clean, vuln_version_pattern):
                vulnerabilities.append({
                    'package': package_name,
                    'installed_version': version,
                    'vulnerable_versions': vuln_version_pattern,
                    'cve': vuln_info['cve'],
                    'severity': vuln_info['severity'],
                    'description': vuln_info['description'],
                    'recommendation': f'Update {package_name} to latest version'
                })
        
        return vulnerabilities
    
    def _clean_version(self, version: str) -> str:
        """Clean version string (remove ^, ~, etc.)"""
        return re.sub(r'[^0-9.]', '', version)
    
    def _version_matches_pattern(self, version: str, pattern: str) -> bool:
        """
        Check if version matches vulnerability pattern.
        Simplified implementation - production would use semver library.
        """
        if pattern.startswith('<'):
            threshold = self._clean_version(pattern[1:])
            return self._compare_versions(version, threshold) < 0
        elif pattern.startswith('<='):
            threshold = self._clean_version(pattern[2:])
            return self._compare_versions(version, threshold) <= 0
        elif pattern.startswith('>'):
            threshold = self._clean_version(pattern[1:])
            return self._compare_versions(version, threshold) > 0
        elif pattern.startswith('>='):
            threshold = self._clean_version(pattern[2:])
            return self._compare_versions(version, threshold) >= 0
        else:
            return version == pattern
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """
        Compare two version strings.
        Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2
        """
        try:
            parts1 = [int(x) for x in v1.split('.')]
            parts2 = [int(x) for x in v2.split('.')]
            
            # Pad to same length
            max_len = max(len(parts1), len(parts2))
            parts1 += [0] * (max_len - len(parts1))
            parts2 += [0] * (max_len - len(parts2))
            
            for p1, p2 in zip(parts1, parts2):
                if p1 < p2:
                    return -1
                elif p1 > p2:
                    return 1
            return 0
        except:
            return 0


def scan_for_vulnerabilities(extension_path: str) -> Dict:
    """Convenience function to scan extension for vulnerabilities"""
    scanner = VulnerabilityScanner()
    return scanner.scan_extension(extension_path)
